# The C#/.NET Security Pitfalls Compendium: 100 Critical Mistakes

## Input Validation & Sanitization

1. **Trusting user input without validation** - Always validate length, format, and content
2. **Missing input encoding before database queries** - Leads to SQL injection
3. **Not validating file upload types** - Allows malicious file uploads
4. **Insufficient validation of file sizes** - Enables denial of service attacks
5. **Trusting Content-Type headers** - Verify actual file content, not just headers
6. **Missing validation on redirects** - Allows open redirect vulnerabilities
7. **Not sanitizing HTML input** - Enables XSS attacks
8. **Trusting deserialized data** - Can lead to remote code execution
9. **Missing regex input validation** - Allows unexpected input patterns
10. **Not validating numeric ranges** - Causes integer overflow/underflow

## SQL Injection

11. **Using string concatenation for SQL queries** - Classic SQL injection vector
12. **Not using parameterized queries** - Essential defense against SQL injection
13. **Trusting stored procedure parameters without validation** - Still vulnerable
14. **Dynamic SQL construction** - Dangerous when using user input
15. **Using Entity Framework with raw SQL improperly** - Bypasses ORM protections
16. **Not escaping special characters in LINQ** - Can introduce vulnerabilities
17. **Concatenating table/column names from user input** - Allows schema manipulation

## Cross-Site Scripting (XSS)

18. **Not encoding output in Razor views** - Use `@Html.Encode()` or `@` syntax
19. **Using `Html.Raw()` with user input** - Dangerous and unnecessary
20. **Missing Content Security Policy headers** - Reduces XSS protection layers
21. **Not sanitizing JavaScript event handlers** - Allows script injection
22. **Trusting data in JavaScript contexts** - Always encode for JavaScript
23. **Using `innerHTML` with user content** - Prefer `textContent` or encoding
24. **Not validating URLs in href attributes** - Allows javascript: protocol

## Authentication & Authorization

25. **Not using ASP.NET Identity properly** - Reinventing authentication is risky
26. **Storing passwords in plain text** - Always hash with salt
27. **Using weak hashing algorithms (MD5, SHA1)** - Use bcrypt, Argon2, or PBKDF2
28. **Missing password complexity requirements** - Weakens account security
29. **Not implementing account lockout** - Allows brute force attacks
30. **Missing multi-factor authentication** - Single factor is insufficient
31. **Not invalidating sessions on logout** - Leaves sessions exploitable
32. **Using predictable session IDs** - Use cryptographically random values
33. **Missing authorization checks** - Check permissions on every request
34. **Relying only on client-side authorization** - Always verify server-side
35. **Not implementing role-based access control properly** - Leads to privilege escalation
36. **Trusting JWT tokens without validation** - Verify signature and claims
37. **Storing sensitive data in JWT payload** - JWTs are not encrypted by default
38. **Not rotating refresh tokens** - Long-lived tokens are risky
39. **Missing CSRF tokens** - Allows cross-site request forgery
40. **Not using secure cookie flags** (HttpOnly, Secure, SameSite)

## Cryptography

41. **Using weak encryption algorithms (DES, RC4)** - Use AES-256 or better
42. **Hardcoding encryption keys** - Use key management systems
43. **Not using initialization vectors (IVs) properly** - Must be random and unique
44. **Reusing IVs** - Compromises encryption security
45. **Using ECB mode** - Use CBC, GCM, or other secure modes
46. **Not authenticating encrypted data** - Use HMAC or authenticated encryption
47. **Implementing custom cryptography** - Use established libraries
48. **Using Random instead of RNGCryptoServiceProvider** - Not cryptographically secure
49. **Storing keys alongside encrypted data** - Defeats encryption purpose
50. **Not using TLS for data in transit** - Exposes data to interception

## Sensitive Data Exposure

51. **Logging sensitive information** - Passwords, tokens, PII should not be logged
52. **Exposing stack traces to users** - Reveals system architecture
53. **Detailed error messages in production** - Information disclosure vulnerability
54. **Not encrypting connection strings** - Use protected configuration
55. **Storing secrets in source code** - Use Azure Key Vault or similar
56. **Including secrets in configuration files** - Use environment variables
57. **Not clearing sensitive data from memory** - Use SecureString when appropriate
58. **Exposing internal paths in errors** - Reveals directory structure
59. **Not masking sensitive data in logs** - Credit cards, SSNs should be redacted
60. **Caching sensitive pages** - Use appropriate cache headers

## XML & Deserialization

61. **Using XmlReader without DTD processing disabled** - XXE attack vector
62. **BinaryFormatter deserialization** - Known remote code execution risk
63. **JavaScriptSerializer with type resolution** - Can execute arbitrary code
64. **Not validating XML schema** - Allows malformed data processing
65. **Using XmlDocument without restrictions** - Vulnerable to XML bombs
66. **Deserializing untrusted data** - Use safe serializers like System.Text.Json
67. **Not limiting XML entity expansion** - DoS through billion laughs attack

## API Security

68. **Missing rate limiting** - Allows abuse and DoS attacks
69. **Not versioning APIs properly** - Makes security updates difficult
70. **Exposing internal object structures** - Information disclosure
71. **Missing API authentication** - Allows unauthorized access
72. **Using HTTP instead of HTTPS** - Exposes data in transit
73. **Not validating Content-Type** - Allows unexpected data formats
74. **Missing input size limits** - DoS through large payloads
75. **Exposing detailed API errors** - Information leakage
76. **Not implementing CORS properly** - Allows unauthorized cross-origin requests
77. **Mass assignment vulnerabilities** - Bind only necessary properties

## Dependency Management

78. **Using outdated NuGet packages** - Known vulnerabilities remain unpatched
79. **Not monitoring for security advisories** - Miss critical updates
80. **Including unnecessary dependencies** - Increases attack surface
81. **Not verifying package integrity** - Supply chain attacks
82. **Using packages from untrusted sources** - Malicious code injection risk

## Code Quality & Logic

83. **Race conditions in concurrent code** - Use proper synchronization
84. **Not disposing IDisposable resources** - Memory leaks and resource exhaustion
85. **Integer overflow without checks** - Use checked arithmetic for critical operations
86. **Path traversal vulnerabilities** - Validate and sanitize file paths
87. **Command injection through Process.Start()** - Sanitize arguments carefully
88. **LDAP injection** - Parameterize LDAP queries
89. **Using eval() or dynamic code execution** - Extremely dangerous with user input
90. **Not handling exceptions properly** - May expose sensitive information
91. **Insufficient logging** - Hampers security incident detection
92. **Time-of-check time-of-use (TOCTOU) errors** - Validate state at use time

## Configuration & Deployment

93. **Running with excessive permissions** - Follow least privilege principle
94. **Debug mode enabled in production** - Exposes debugging information
95. **Not using security headers** (X-Frame-Options, X-Content-Type-Options, etc.)
96. **Permissive CORS policies** - Use specific origins, not wildcards
97. **Not implementing security.txt** - Hinders responsible disclosure
98. **Default credentials not changed** - Easy target for attackers
99. **Unnecessary services and features enabled** - Increases attack surface
100. **Not implementing security monitoring** - Delayed breach detection

---

## Recommended Resources

- OWASP Top 10 for .NET
- Microsoft Security Development Lifecycle (SDL)
- .NET Security Cheat Sheet
- Static analysis tools: SonarQube, Security Code Scan
- Dynamic testing: OWASP ZAP, Burp Suite
